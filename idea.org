* Background Process
** config json
   - *command*
   - list of *channels* {ch1, ch2, ch3, ...}, eg
     { icon   (busy/idle/shutdown), 
       status (copying X to Y ...), 
       file-list,
       error-list,
       notify  }
     - Each channel is a list of tuples of a prescribed form, e.g.
     - One of the labels can be marked as the label used for compression of the list.  Eg, if full path is marked for compression, adding a new item to the list will delete any older item with the same full path.
     - Each list should have a maximal length.
     Thus, an definition of a channel might look something like:
     { name : file-list-channel
       entries : { time , file, full path},
       max-length: 30
       compression: full path }
     By default, the maximal length is 1, and there is no compression.
   - list of *filters* in the form
     { input pattern: ...,
       output to ch1: ...,
       output to ch2: ...,
        etc.  }
    
** class initialization
   - config json
   - generic callback function signal()
     (a call to self.signal(channel-id) signals that the channel with the specified i.e. has been updated)
   - a specific callback function for each channel
     { 'ch1': function1, 'ch2': function2, ...}
     functionX takes the current state of channelX as an argument
     (just the last value, not the whole list)
    
** methods provided
   - run()
     starts the command as a process in a separate thread and "watches" it, filtering the output according to the filters in config.json
   - abort()
   - quit()
   - report(channel-id, all=False)
     returns current state of the channel (the whole list if all==True)
    
   Thus, there are two ways to track the output of a certain channelX:
    
   (A) Initialize the channel-specific callback function functionX 
       For example, this can be initialized to print channelX to the screen or to a log file.
   (B) Wait for the callback function signal() to receive channelX as argument.  Then call report(channelX) and work with whatever this channel returns.
       For example, this can be used to update an indicator icon only periodically, or the display the last 30 log entries on demand, etc.
    
* Conveyer
** config
  (1) *Commands*.  Each command has the form:
     - description
     - command (actual string to pass to the command line)
     - filter (which filter.json to use)
     - icons associated with the known states
     - mappings of the channels to menu entries and notify, eg:
          state --> menu-entry 'status'
          file  --> menu-entry 'file0'  (expands to a list)
                    with text :           file.file, 
                    associated operation: open file.fullpath
          error --> notify with icon: ..., heading: ..., text: ...
     For example, the following item in the file list
     {  time : 12:43,
        file : very-long-and-bad-filename.py }
	path : ~/bin/ }
     should be converted to a menu entry with label
          [12:43] very-...-name.py
     and associated command
          open folder ~/bin/

   (2) Description of the *menu* of the app-indicator
       using syntax of gui-o-matic
       - menu entries can be connected to different kinds of 'commands':
         - all the usual commands of gui-o-matic (open url, ...)
         - the background processes described above
           [a call to one of these while the app is busy creates a second instance of the app.]
	 - some predefined commands like 'show list L of Background Process P'
      - menu entries can be marked as 'beginnings of a list'
      eg:
        -| 'status'
        -| 'available networks 0' (expand dynamically into list)
        -| 'errors' 
        ---| 'error 0' (expand dynamically into list)
        -| entry 'quit'
   
   (3) *Default routine*
       in terms of the commands listen in (1) and some predefined commands.  Eg: 
       - BackInTime
         on-fail: abort
       - Unison-Watch
	 on-fail: retry-after-waiting(factor)
